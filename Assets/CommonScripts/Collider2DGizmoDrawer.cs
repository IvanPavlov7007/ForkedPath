using UnityEngine;

//generated by ChatGPT
[ExecuteAlways]
[RequireComponent(typeof(Collider2D))]
public class Collider2DGizmoDrawer : MonoBehaviour
{
    private Collider2D col;

    void OnDrawGizmos()
    {
        col = GetComponent<Collider2D>();
        //Gizmos.color = PriorityToColor(area.priority);

        switch (col)
        {
            case PolygonCollider2D poly:
                DrawPolygon(poly);
                break;
            case BoxCollider2D box:
                DrawBox(box);
                break;
            case CircleCollider2D circle:
                DrawCircle(circle);
                break;
            case CapsuleCollider2D capsule:
                DrawCapsule(capsule);
                break;
            case EdgeCollider2D edge:
                DrawEdge(edge);
                break;
        }
    }

    Color PriorityToColor(int priority)
    {
        float t = Mathf.InverseLerp(0, 2, priority); // Adjust min/max as needed
        return Color.Lerp(Color.green, Color.red, t);
    }

    void DrawPolygon(PolygonCollider2D poly)
    {
        for (int p = 0; p < poly.pathCount; p++)
        {
            var points = poly.GetPath(p);
            for (int i = 0; i < points.Length; i++)
            {
                Vector3 a = transform.TransformPoint(points[i]);
                Vector3 b = transform.TransformPoint(points[(i + 1) % points.Length]);
                Gizmos.DrawLine(a, b);
            }
        }
    }

    void DrawBox(BoxCollider2D box)
    {
        Vector2 size = box.size * 0.5f;
        Vector2 offset = box.offset;
        Vector2[] corners = new Vector2[4]
        {
            new Vector2(-size.x, -size.y),
            new Vector2(-size.x, size.y),
            new Vector2(size.x, size.y),
            new Vector2(size.x, -size.y)
        };

        for (int i = 0; i < 4; i++)
        {
            Vector3 a = transform.TransformPoint(corners[i] + offset);
            Vector3 b = transform.TransformPoint(corners[(i + 1) % 4] + offset);
            Gizmos.DrawLine(a, b);
        }
    }

    void DrawCircle(CircleCollider2D circle)
    {
        Vector3 center = transform.TransformPoint(circle.offset);
        float radius = circle.radius * Mathf.Abs(transform.lossyScale.x); // assumes uniform scale

        const int segments = 32;
        float angleStep = 360f / segments;
        Vector3 prevPoint = center + Quaternion.Euler(0, 0, 0) * Vector3.right * radius;

        for (int i = 1; i <= segments; i++)
        {
            float angle = i * angleStep;
            Vector3 nextPoint = center + Quaternion.Euler(0, 0, angle) * Vector3.right * radius;
            Gizmos.DrawLine(prevPoint, nextPoint);
            prevPoint = nextPoint;
        }
    }

    void DrawCapsule(CapsuleCollider2D capsule)
    {
        // Approximate with an oval shape using arcs + straight sides
        Vector3 center = transform.TransformPoint(capsule.offset);
        float height = capsule.size.y * transform.lossyScale.y;
        float width = capsule.size.x * transform.lossyScale.x;
        float radius = Mathf.Min(width, height) / 2f;

        const int arcSegments = 16;
        float angleStep = 180f / arcSegments;

        Vector3 topCenter = center + Vector3.up * (height / 2 - radius);
        Vector3 bottomCenter = center - Vector3.up * (height / 2 - radius);

        Vector3 prevTop = topCenter + Quaternion.Euler(0, 0, 0) * Vector3.right * radius;
        Vector3 prevBottom = bottomCenter + Quaternion.Euler(0, 0, 180) * Vector3.right * radius;

        // Top arc
        for (int i = 1; i <= arcSegments; i++)
        {
            float angle = i * angleStep;
            Vector3 nextTop = topCenter + Quaternion.Euler(0, 0, angle) * Vector3.right * radius;
            Gizmos.DrawLine(prevTop, nextTop);
            prevTop = nextTop;
        }

        // Bottom arc
        for (int i = 1; i <= arcSegments; i++)
        {
            float angle = 180 + i * angleStep;
            Vector3 nextBottom = bottomCenter + Quaternion.Euler(0, 0, angle) * Vector3.right * radius;
            Gizmos.DrawLine(prevBottom, nextBottom);
            prevBottom = nextBottom;
        }

        // Connect arcs
        Gizmos.DrawLine(topCenter + Vector3.left * radius, bottomCenter + Vector3.left * radius);
        Gizmos.DrawLine(topCenter + Vector3.right * radius, bottomCenter + Vector3.right * radius);
    }

    void DrawEdge(EdgeCollider2D edge)
    {
        var points = edge.points;
        for (int i = 0; i < points.Length - 1; i++)
        {
            Vector3 a = transform.TransformPoint(points[i] + edge.offset);
            Vector3 b = transform.TransformPoint(points[i + 1] + edge.offset);
            Gizmos.DrawLine(a, b);
        }
    }
}